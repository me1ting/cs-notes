## 为什么需要三次握手？

>《计算机网络5》 6.2.2

三次握手拆分开来，就是两次`发送-确认`的过程，核心就是客户端和服务端分别发送初始化信息并要求得到对方的确认。

要回答“为什么需要”，那么就要假设不需要会是什么情况。不需要三次握手有两种情况：

情况1，服务端不需要等待客户端确认（ACK），就认为连接已经建立。这会导致，因为网络问题而存在的旧连接的`SYN`会触发服务端建立起新的连接。

情况2，客户端不需要等待服务端的确认（SYN ACK），就认为连接已经建立。但没有服务端的初始化信息（如序号），这样的连接是无法保证有序、可靠的。

## 为什么需要四次挥手？

>《计算机网络5》 6.2.3

连接释放分为两种：非对称释放、对称释放。

非对称释放的典型就是电话，任意一方选择挂断电话，整个连接就断开了。但带来的风险是，一方可能还有更多想说的，导致信息丢失。

对称释放的两方都需要独立的关闭该方向的发送需求。

对于可靠的连接而言，断开连接是需要通知双方的。对于TCP而言，关闭表示发送方不再发送数据，但接收方可能还在发送数据，只有两者都通知不再发送数据，**才能避免数据丢失的风险**。

实现上来讲，存在一些细节：

- 由于`两军对垒问题`，即使关闭请求方没有收到响应，使用计时器，它只需要等待两倍最大包生存期就可以关闭连接
- TCP要求使用心跳数据保持连接，两端在超时后可以选择断开连接

>两军对垒问题：两支军队在围攻敌人，没有一种方法能够保证穿越敌人的信号兵能够将发起围攻的时间通知给另一方，因为最后总需要一个人来确认前面所有的信息传递是OK的，但他所在方无法确定他能够正确到达对面。

# 三次握手中服务端拒绝连接会发生什么 ？

取决于“拒绝”的定义：

- 服务端没有监听端口，无法响应SYN数据包，客户端会尝试重传直到放弃
- 服务端返回RST数据包，表示拒绝连接，客户端返回错误

# 两个TCP建立请求相互之间同时发起时会发生什么？建立几个连接？

一般而言，TCP连接区分发起方（客户端）和接受方（服务端），如果两个建立连接请求指的是同时发送SYN数据包，理论上来讲这是可能的，相当于服务端的SYN&ACK数据包被拆分并将SYN部分提前进行了发送，最后只会建立一个连接。

# 客户端正在和服务端建立 TCP 连接，然而当服务器变 SYN-RCVD 后，此时一个旧的 SYN 报文 又到达了，服务器会如何处理？

服务端接受到了SYN才变成SYN-RCVD状态，根据正确的SYN可以判断旧的SYN是重复的，服务端会丢弃旧的SYN段。

# TCP第三次握手失败怎么办，即最后一次握手失败?

失败指`ACK`丢失，这取决于具体实现。一般来讲，服务端在等待客户端的确认时会启动计时器，超时则重传，尝试超过一定次数时，那么就会关闭这个连接。

这时客户端可能会遇到几种情况：

- 服务端已经关闭，客户端发送数据或者重传ACK时，服务端会返回RST分组，客户端会关闭这个连接。
- 服务端仍在等待，客户端发送数据或者重传ACK，服务端接受到ACK，连接建立。

# 知道SYN攻击吗？如何防范？

SYN攻击是一种拒绝服务攻击，服务端在接收到SYN分组时，服务器会为客户端请求分配资源，并返回SYN ACK分组，将请求存放在半连接队列中；服务器对得不到回复会不断地重发请求，直到达到设定的时间/次数后，才会关闭。因此攻击者可以通过发送大量SYN分组，来使得服务端耗尽资源，拒绝服务。

防范方法是服务端对连接请求不再分配资源，而是使用SYN cookie，将需要保存的信息使用特定的hash生成cookie，通过SYN ACK返回，下次ACK分组来时校验cookie，并根据这个分组携带的信息生成所需要的信息。

SYN cookie的缺点在于：

- 服务端不再保存连接的半开状态，因此失去了重发SYN ACK的能力，降低了用户的连接成功率

因此默认情况下，linux服务器将SYN cookie作为服务器负载压力大下的解决方案，也就是半开队列满以后，使用SYN cookie来接收后续连接。

# 三次握手过程中可以携带数据吗？

第三次握手可以携带，只是在握手完成前无法交付给应用层。
