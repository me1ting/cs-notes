# 简介
用户空间TCP/IP栈实现需要网络第2层/第3层(以标准模型来看)的相关接口提供支撑，而TUN/TAP就是这些支撑。

TAP/TUN是虚拟网络设备，提供用户空间访问网络第2层/第3层的能力。TAP工作在第二层，使得用户空间能收发以太网帧。TUN工作在第三层，使得用户空间能收发IP数据报。

```
应用程序-->TAP/TUN-->附加在TAP/TUN的处理程序-->真实网络设备
真实网络设备-->附加在TAP/TUN的处理程序-->TAP/TUN-->应用程序
```

# Linux
## 创建、删除、管理虚拟网络设备
### 使用命令行
可以使用命令行来创建虚拟网络设备：
```
# 创建tap
sudo ip tuntap add user <username> mode tap <device-name>
# 删除虚拟设备
sudo ip tuntap del mode tap <device-name>
# 开启设备
ip link set dev <device-name> up
# 关闭设备
ip link set dev <device-name> down
# 分配地址
ip addr add <ipv4-address>/<mask-length> dev <device-name>
```
更多命令可以参考redhat的[文档](https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf)

上面的tap替换为tun就是创建TUN设备。

### 使用API
使用API，我们可以创建、读写虚拟网络设备。

#### 附加到虚拟网络设备，得到文件描述符

C语言实现可以参考：[3.1 Network device allocation](https://www.kernel.org/doc/Documentation/networking/tuntap.txt)

Go语言实现可以参考[tun_unsafe.go](https://github.com/google/netstack/blob/master/tcpip/link/tun/tun_unsafe.go)

C API难以理解，本笔记的关注点不在于C或CGo，因此只需要大致了解。

Go实现与C实现唯一的不同在于使用了非阻塞API：
```go
if err = syscall.SetNonblock(fd, true); err != nil {
	syscall.Close(fd)
	return -1, err
}
```
这与Go的channel,goroutine实现机制有关，Go在调用所有底层IO API时，都是使用无阻塞API的。

#### 使用文件描述符，读写数据
这涉及到Linux的IO编程，对没有涉及过这方面的人来说，理解起来会比较痛苦。

Go语言实现可以参考[rawfile_unsafe.go](https://github.com/google/netstack/blob/master/tcpip/link/rawfile/rawfile_unsafe.go)。
