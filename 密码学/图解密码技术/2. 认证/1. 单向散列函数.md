# 基本概念

验证字节序列（文件、消息）的`完整性`的一个有效办法是获取数据的“`指纹`”。

`单向散列函数`：输入为`消息`，通过特定计算，得到一串固定长度的`散列值`。与术语`哈希函数`、`消息摘要函数`基本等同。

`散列值`：与术语`消息摘要`、`指纹`等同。

`完整性`：与术语`一致性`等同。

单项散列函数应当具备以下性质：

- 任意长度的消息都可以计算出固定长度的散列值
- 计算速度要快
- 消息不同，散列值不同，能够避免`碰撞`
- 单向性，无法从散列值中反算出消息

`碰撞`：两个不同的消息产生同一个散列值得情况。

`抗碰撞性`：散列函数难以被发现碰撞的能力，根据场景不同，区分两种

- `弱抗碰撞性`：给定某条消息时，难以发现找到具备相同散列值得另一条消息

- `强抗碰撞性`：找到散列值相同的两条消息是很难的

*从原理上来讲，散列函数的作用是将一个无穷大的值域映射到一个有限大小的值域，存在碰撞的可能性是100%的。散列函数需要避免的是人为地发现碰撞，或者说增大人为发现碰撞的成本使其超过原始消息完整性的价值*

# 应用

单向散列函数的应用领域包括：

## 验证软件的完整性

通常软件下载地址会附带文件的散列值，其作用是可以校验下载结果、第三方下载结果相对于**官网版本**的完整性。

## password的加密

避免原始password的泄露，同时为了避免字典攻击，需要添加`盐(salt)`混合后进行散列。

## 消息认证码

将共享密钥与消息混合后计算散列值，避免通信过程中，产生消息错误、被篡改、被伪装。

## 数字签名

由于计算效率，一般对消息摘要进行数字签名。

# 单向散列函数

## MD4,MD5

使用128位散列值，MD5的强抗碰撞性已经被攻破，因此被淘汰。

## SHA-1,SHA-2（SHA-256,SHA-384,SHA-512）

单向散列函数的美国国家标准。其中，SHA-1使用160位散列值，其余的散列值位数与其后缀等同。

SHA对于消息的长度存在上限，分别接近2^64bit(1TB为2^15bit)与2^128bit，在实际应用中是够用的。

SHA-1的强抗碰撞性已经被突破，因此目前也被淘汰。

## SHA3

SHA-1,SHA-2是由具有美国政府背景的NSA设计，而SHA3则不同，它采取与AES一样的公开招标的方式。

# 单向散列函数的攻击

## 暴力破解实现内容篡改

实际文件存在两种冗余性：

- 字节层面，文件格式的字节表示存在一些冗余空间，篡改它们对其承载的内容不会产生太大影响
- 内容层面，文字存在近似的表达，其它媒体内容同理

利用冗余性，我们可以快速的构造出承载了我们想要修改内容的巨大样本空间，然后只需要测试这些样本是否实现碰撞。

从概率上来讲，对于160位的散列值，只需要最多尝试`2^160`次散列计算，就会得到想要的结果。因此散列值长度越长的函数，其抵抗暴力破解的能力也就越强。

暴力破解是对散列函数的弱抗碰撞性的攻击。

## 生日攻击

`生日问题`：在N个人中，保证至少有两个人的生日相同的概率大于1/2，N至少多少？

解答：N=23，很多人会靠直觉得出远大于这个数目的答案。

`生日悖论`：任何生日相同的概率远大于直觉值。

可以将生日看作一种随机映射关系，将其一般化得到：N个数的集合映射到大小为Y的值域，当至少有两个数映射到同一个值时的概率大于1/2时，N至少应该为多少？

解答：数学计算可以得出，N约等于 Y开平方。

生日攻击的基本策略如下：攻击者只需要获取具有相同散列值的文件A,文件B，将A交给目标，最终却替换为B。

如何找到A,B呢？

- 利用冗余性，生成N份A，N份B
- 逐一对比，直到找到具有相同散列值的A,B，最差O(N^2)，使用排序查找算法更快

以160位的散列值为例，此时的Y大小为$2^{160}$，N大小为$^{80}$。因此散列值越长的函数，其抵御暴力破解的能力也就越强。

对比暴力攻击，生日攻击需要尝试的次数明显降低，以160位散列值为例，前者最多需要$2^{160}$次散列计算，后者最多需要$2*2^{80}$次散列计算。

# 单向散列函数的局限

`篡改`：消息被第三方修改

`伪装`：第三方同时替换消息和散列值

单向散列函数可以抵御消息篡改，但无法抵御消息伪装。

