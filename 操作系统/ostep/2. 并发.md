# 基本概念

## 线程

`线程`是进程的多个执行点，类似进程，但是共享地址空间。

>线程的概念在OS/360（20世纪60年代）就已经出现，并在21世纪初随着多核CPU的流行而大放异彩。- [wiki](https://en.wikipedia.org/wiki/Thread_(computing))

线程给底层实现带来的挑战是：

- 需要类似使用PCB的结构来记录线程的环境，参与执行线程的切换
- 虚拟地址空间的栈空间现在被多个线程所共享，需要额外的管理子程序

## 多线程给编程带来的挑战

线程使得编程出现了以下两类问题，解决这些问题需要硬件提供一些基本机制（硬件原语），软件提供一些通用抽象（同步原语）。

*术语`原语`用于描述硬件提供的底层API（硬件原语），以及基于硬件原语封装的用于同步的基础API（同步原语）*

### 共享变量问题

当多个线程读写相同的变量时，先后顺序是未定义的，这使得程序的运行结果是不确定性的。

相关术语：

- `并发`：多个执行流**逻辑**上同时执行
- `共享变量`：同一地址空间下，被多个线程访问的变量
- `竞争条件`(race condition)：这个中文翻译容易让人产生误解，正确的翻译应当为”竞争状态“，指多个线程同时访问共享变量的情况
- `临界区`：访问共享变量的代码片段

解决共享变量问题的基本策略是：**同步**，临界区的执行应当是**原子的**，或者说**互斥的**，同时只能有一个线程访问临界区。

### 等待执行问题

一个线程等待某些条件完成（由其它线程达成），也就是线程等待其它线程的执行到特定点。

*除了以上两个问题，多线程编程还存在 可见性 问题，请参考其它学习资料学习*
# 锁

保证互斥的最简单方式是使用`锁`，这是一个来自现实世界的抽象。在临界区前后分别执行加锁和解锁操作，使得临界区的执行是原子性的。

## 基本抽象

在编程语言中，锁是一个对象，提供`lock()`和`unlock()`，分别表示加锁和解锁。

## 评估标准

锁的实现可以从以下维度来考量：

- 功能性，能否实现锁的基本功能和额外功能
- 公平性，线程执行临界区的权利是否公平分配
- 性能

## 实现方式

锁主要有两种实现方式：

- 中断控制，细节介绍参考书中内容，缺点较多，也未考证是否被实际使用
- 使用硬件原语，这是普遍的实现方式

## 自旋锁

锁的实现可以分为`机制`和`策略`两部分，基本机制是利用硬件原语，如TAS,CAS等原子操作，实现最基本的自旋锁。`自旋`用于描述程序不断尝试使用硬件原语直到操作成功的加锁过程。

自旋锁的问题是，轮询操作使得CPU”空转“，性能较低；其余线程没有机会获取锁，因此是不公平的。

## 两阶段（two-phase）锁

锁实现的策略部分将解决自旋锁的性能和公平问题，最常见的策略是两阶段锁：线程尝试获取锁（自旋一定次数），如果失败，将线程添加到等待队列，线程进入休眠。当锁被释放时，唤醒等待队列中的一个线程。

相关术语：

- `休眠`：线程等待在锁上，不可以被调度，直到被唤醒
- `唤醒`：线程可以被调度

### yield原语

`yield原语`是让线程由执行状态进入就绪状态的低级操作，是与线程有关的重要原语。在书中的本章节被介绍，但并不是实现锁的关键步骤。

## 基于锁的并发数据结构

为了实现`线程安全`的数据结构，使用锁是最简单的办法。

`线程安全`：不需要额外的同步手段，对数据的访问是安全的。

## 优化手段

使用全局锁能够实现线程安全，但是性能不够。我们可以使用多个锁，只对局部进行加锁，减小锁造成的性能问题，这样的方式称为`减小锁的粒度`。

# 条件变量

`条件变量`被发明用于解决`等待执行问题`。

## 基本抽象

线程可以在条件变量上调用`wait()`，进入休眠并等待被唤醒；线程可以使用`signal()`唤醒等待在目标条件变量上的其它一个线程；线程也可以使用`signalAll()`唤醒在目标条件变量上的其它所有等待线程。

## 等待队列

条件变量维护了一个队列，线程将自己放入队列中（等待该条件），再休眠；其它进程实现了该状态时，可以唤醒队列中的一个或多个线程。

## 条件变量与锁

条件变量关联了一个`条件状态`，线程对条件状态的访问需要同步处理，因此条件变量需要配合锁使用。

典型的条件变量API会要求使用者在持有锁的情况下，才能调用`wait()`和`signal()`。

## 生产者和消费者问题

CS先驱Dijkstra提出的一个同步问题：假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。如何实现？

这个问题抽象了一系列现实问题，因此成为了并发领域的经典问题。

因为缓存区是共享变量，因此需要对缓冲区的访问操作进行同步处理。

## Mesa语义和Hoare语义

当调用singal()，唤醒等待线程时，该线程得以立即执行，是Mesa语义；该线程的状态为就绪，是Hoare语义。Mesa语义指被唤醒的线程拥有执行权，而Hoare指被唤醒的线程允许被调度，具体执行哪个线程由调度程序确定。

目前主流的`singal()`实现采用的是Hoare语义，程序被唤醒再次执行时，应当再次测试条件是否满足需求。

# 信号量

CS先驱Dijkstra发明的一个同步原语，用于解决生产者和消费者问题。

## 基本抽象

信号量是一个整数值，有两个操作：

- `wait()`消费者线程等待信号量为正数，消耗一个信号量（信号量-1），否则休眠
- `post()`生产者生产信号（信号量+1），唤醒一个休眠的线程

## 二元信号量

信号量的合法值为0,1的信号量。二元信号量保证同时只有1个线程进入临界区，因此可以用作互斥锁。

## 使用信号量实现条件变量

同步原语提供的功能足以使得它们直接用来实现彼此，在实际中，如果方便，将一个同步原语用作另一种同步原语是常有的。

## 读写锁

读写锁是一种常用的同步工具，用于：读写互斥，读之间不互斥。一般会使用两个锁：读锁、写锁来实现，可以使用信号量来实现读锁，demo见书中代码。

## 哲学家就餐问题

CS先驱Dijkstra提出的又一个经典同步问题，有趣但实用性不大，但有助于我们理解一些关键概念。

哲学家就餐问题：假设有五个哲学家，它们的左右手分别有一把餐叉，只有同时拿有两把餐叉才能就餐，总共有5把餐叉，应该如何就餐？

我们可以将哲学家就餐问题使用如下代码表示：

```go
// 使用编号0,1,2,3,4表示哲学家
forks := make([]bool,5)// 使用编号0表示哲学家0左手边餐叉，使用编号1表示哲学家0右手边餐叉...

// 返回哲学家n左手餐叉
func left(n int)int {
	return n
}

// 返回哲学家n右手餐叉
func right(n int)int {
	if n < 4 {
		return n+1
	}
	return 0
}

// 哲学家n就餐
func eat(n int){
	wait(left(n))
	wait(right(n))
	fmt.Printf("%d is eating...\n", n)
	post(left(n))
	post(right(n))
}

// 等待餐叉n
func wait(n int){
	//伪代码
}

// 放下餐叉n
func post(n int){
	//伪代码
}

func main(){
	for i:=0;i<5;i++ {
		n:=i
		go func(){
			eat(n)
		}
	}
	//假设不退出
}
```

我们对拿取每个餐叉和释放餐叉进行同步处理，每个餐叉同一时间只能被一个哲学家拥有。这段代码存在经典的问题：**死锁**。

想象一下，所有哲学家同时拿上左手的餐叉，会是什么情况？所有哲学家都在等待右手上的餐叉被放下，但永远不会发生，所有哲学家都将饿死。

解决办法很简单，只要其中一个人先拿右手边的餐叉。

# 并发常见BUG问题

## 死锁

类似哲学家问题，多个线程获取多个锁资源存在冲突，进入互相等待的状态。有时，我们也会将线程进入永久等待状态的情况称为死锁，并不要求必须是多个线程和交叉获取。

### 避免死锁

可以从以下角度来避免死锁：

- 按照特定顺序获取锁，不允许逆序
- 使用一个全局锁，使得获取多个锁的过程是原子性的
- 提供非抢占的锁接口，如`tryLock()`，线程在尝试获取下个锁失败时，可以释放已获取的锁再尝试
- 不使用锁，直接使用硬件原语，无等待/无锁并发数据结构就是基于这种思想
- 检测和恢复

## 活锁

多个线程争抢锁失败，虽然没有全部阻塞或休眠，但只是重复的失败，程序并没有前进。

# 基于事件的并发

并发指多个执行点在逻辑上的同时执行，事件循环是和多线程一样流行的并发解决方案。

## 基本抽象

事件循环在一个循环中不停的获取就绪的事件，然后执行：

```go
for {
	event := tryGetEvent()
	if event!=nil {
		event.Execute()
	}
}
```

可以对比单CPU上的多线程程序，同一时间只能运行一个执行流，调度算法使得多个执行流得以交替执行。多线程程序为了解决它所面临的问题，发明了一系列同步原语，使得程序极为复杂。

事件循环采用简单易懂的顺序执行模型：从事件队列里面顺序的取出任务，然后执行，因为执行流并不交替，因此不存在类似多线程的问题。

## API

Unix的`select()`,`poll()`是典型的事件循环API，支持对I/O的基于事件循环的并发读写。

## 阻塞、非阻塞、同步、异步

这几个修饰词放在一起讨论的时候，是**描述I/O接口**时，抛开该场景去讨论这几个词的概念没有什么意义。

I/O操作的底层细节可以划分为两个部分：

- 读写就绪，以读为例，等待数据到达内核缓冲区，这些数据可能来自网络、磁盘..
- 复制数据，以读为例，将内核缓冲区的数据拷贝到用户空间中

- `阻塞I/O` 如果读写未就绪，线程会进入`阻塞`状态，直到读写就绪，阻塞状态的线程不会被调度。
- `非阻塞I/O` 如果读写未就绪，I/O接口立即返回错误码。非阻塞I/O需要轮询接口，直到不再返回错误码表示读写就绪，因此实际中很少使用。
- `异步I/O I/O接口立即返回，内核会在读写就绪后，复制数据。
- `同步I/O` 非异步I/O都可以看作是同步I/O，但是一般很少使用这个概念。

我们可以在上述具体场景进行抽象，那么：

- `阻塞` 当任务需要等待特定资源就绪时，等待这个过程就是阻塞，选择等待的接口是阻塞接口
- `非阻塞` 当任务需要等待特定资源就绪时，接口返回错误码，这个接口是非阻塞接口
- `同步` 接口等待任务执行完成才返回，这个接口是同步接口
- `异步` 接口立即返回，任务由后台执行，这个接口是异步接口

可以看到，阻塞/非阻塞用于修饰需要等待特定资源的任务，同步/异步用于修饰完成任务的方式。

**本书将阻塞与同步等同，将非阻塞与异步等同，这种理解是错误的。**

### 事件循环中避免使用阻塞操作

`阻塞`操作会导致线程进入阻塞状态，不会被调度，这对于单线程的事件循环程序来说是不可接受的。

## 事件循环中避免执行CPU密集型任务

事件循环一般用于I/O密集型任务，每个事件处理程序应当快速执行，使得单位时间能处理更多的I/O操作，应当避免在事件循环中执行CPU密集型任务。

# 补充：监视器

中文版认为这个概念过时，因此删除了。但是，这个概念对于Java使用者来说可能会感兴趣。Java语言自带的`synchronized`锁就是`监视器`的实现。

`监视器`是一种已经过时了的同步原语，它尝试将同步操作合并到面向对象编程语言的语法中，从而提供更结构化的同步实践。

`监视器`提供了简单的隐式锁，调用监视器的方法时需要加锁，返回会进行解锁。

## 监视器与条件变量？

条件变量是随着监视器一起提出的，监视器需要条件变量配合，用于某些场景。Java中的监视器实现封装了一个条件变量。

## 监视器与Mesa, Hoare语义有什么联系？

Hoare在其论文中，第一次提出了条件变量的概念，并第一个定义了singal()和wait()的确切语义，即Hoare语义。

而Mesa语言的开发者，在创建语言时，采取监视器作为语言的功能，并在实践过程中，发现理论的缺陷，最后提出了Mesa语义。

## Java监视器的缺陷

Java监视器的问题在于，它只支持单个条件变量，在某些场景，如实现生产者/消费者，不能单独的唤醒生产者，或消费者，必须使用notifyAll()来唤醒所有等待线程，导致惊群问题。

此外，Java的监视器锁不支持`tryLock`。

# 总结

本书并发章节从操作系统角度全面介绍的并发相关的基本概念，然而本书也缺乏一些关键概念，比如`可见性`，对于硬件原语也缺乏更细节的介绍，需要学习其它材料。

# 参考资料

[Unix I/O 主要模型介绍](https://chasecs.github.io/posts/unix-io-introduction/)