# 基本概念

## 术语约定

`语言`：在本书中，语言指编程语言本身以及编程语言的实现（编译器、解释器）

## 语言的组成

![](assets/Pasted%20image%2020240305205151.png)

![](assets/Pasted%20image%2020240305205716.png)
### 扫描

这一步骤是`扫描`(scanning)，也称为`词法分析`(lexing或lexical analysis)。

`扫描器`(scanner)或称为`词法分析器`(lexer)，接收文本字符串，将其切分为基本的单元，称为词法单元(token)。

词法单元可能是单个字符，也可能是多个字符。源代码中的一些字符在后续步骤中是没有意义的，比如`空格`，`注释`，在这一阶段被丢弃。

![](assets/Pasted%20image%2020240305205730.png)

### 语法分析

这一步骤是语法分析(`parsing`)。

`解析器`(parser)将词法单元序列(tokens)转换成树形结构，称为`解析树`(parse tree)或`抽象语法树`(abstract syntax tree，简称AST)。

之所以使用树形结构，是因为它能反应语法的嵌套关系。

解析器还负责当出现语法错误时，报告语法错误。

![](assets/Pasted%20image%2020240305210341.png)

### 静态分析

对于标识符(identifier)，如`min`,`max`，需要确定其对应的实体，将它们关联起来，这个步骤称为`绑定`(binding)或者`决议`(resolution)。这个过程涉及到变量的`作用域`(scope)概念。

对于静态类型的语言，我们可以判定相关操作是否是合法的，如果不合法，应当报告类型错误。

通过分析得到的信息有几个存储位置：

- 语法树节点
- 外部的查找表，称为`符号表`(symbol table)
- 中间代码

传统上，将以上所有步骤称为编译器的`前端`(front end)，将代码生成称为编译器的后端`后端`(back end)。

但是从上世纪90年代以来，编译器引入了中间代码，一些人如William Wulf（编译器领域著名计算机科学家）称与之相关的中间步骤为`中端`(middle end)，也有人称为优化器。

### 中间代码

在中端，代码被表示`中间代码`(intermediate representation，简称IR)。

IR作为源代码和构建目标的中间格式，使得编译器可以支持更多的编程语言和目标平台。

### 优化

`优化`(Optimization)指将代码转换具有相同语义但效率更高的形式。

现代编译器的优化操作主要在IR上进行，解释器也可以在运行时对程序进行优化。

### 代码生成(Code generation)

将优化后的AST或者IR转换为可执行代码(generated code)。

有两种可执行代码：

- 虚拟机指令，称为`字节码`(bytecode)
- 真实CPU指令，得到可执行文件

### 虚拟机

字节码有两种执行方式：

- 将字节码编译为真实CPU指令，这种方式也称为提前编译(ahead-of-time compilation，简称AOT)，此时字节码功能与IR功能存在一些重合
- 使用虚拟机解释执行字节码

### 运行时

无论是Native执行还是虚拟机解释执行，一些语言需要额外的服务，提供垃圾回收、反射等功能，这些起着支撑作用的代码片段被称为`运行时`(runtime)。

## 一些特别的实现（捷径）

### 单遍编译器

`单遍编译`(single-pass compilation)指解析、分析、代码生成耦合在一起。

典型的C编译器就是单遍编译器，这种设计是受到当时硬件条件限制所影响的。

### 树遍历解释器

在AST的基础上解释执行代码。

### 转译器(Transpilers)

将一种编程语言转换为另一种编程语言的工具，比如TS转译到JS，C转译到Zig。

### 即时编译(Just-in-time compilation)

即时编译(简称JIT)在程序加载时，将源代码或字节码编译为本地代码。

## 编译器和解释器

`编译`：将源代码转换为另一种代码
`解释`：接受源代码并执行产生结果

现时中的语言可能混合了以上两种技术：

![](assets/Pasted%20image%2020240305220214.png)

*`go run`其实是将源代码编译为Temp可执行文件，然后执行的，因此这里划分到解释有点牵强*