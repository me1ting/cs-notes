# 基本概念

`算法`：使用计算机解决问题的方法。

`数据结构`：计算机组织数据的方式，与算法紧密耦合。


`基础编程模型`：使用特定编程语言时，所使用的特性、库等的集合。

`API`：库对外提供的使用接口。

`模块化编程`：将代码拆分为独立的，隐藏内部实现的，仅提供API的部分，从而便于编写、测试、修改、复用。

`数据类型`：值与对值的操作的集合。

`抽象数据类型`：对使用者隐藏真实表示，仅通过API提供操作的数据类型。

`迭代`：使用循环遍历并处理集合中的数据。

`递归`：函数调用自身的行为。

>以上部分概念属于编程领域，这里用到了进行说明。这些表述不一定精确。

# 数据结构

`数组`：...

`链表`：···
...


# 抽象数据类型

`栈`：集合类型的抽象数据类型，特点是压栈和入栈，采用`后进先出`策略（API见书75页）

`队列`：集合类型的抽象数据类型，特点是存在队首和队尾，采用`先进先出`策略（API见书74页）

...

>更多见本书99页。重要的是，我们要区分数据结构和抽象数据类型。


# 算法分析
`算法分析`：使用`数学`对算法成本（运行时间、内存消耗）建立简洁的模型。

`问题规模`：算法的运行成本一般和输入数据的大小正相关，使用`N`表示。

## 运行时间的数学模型
我们对算法运行时间的计算基于：

- 执行每条语句的耗时
- 每条语句的执行频率

带入问题规模，我们可以得到算法中一条语句的执行频率的数学表达式，如：

$$N^3/6-N^2/2+N/3$$

执行频率乘以耗时得到该语句的运行时间，所有语句的运行时间的求和是算法的运行时间。

但我们不会这么做，因为很多细节难以确定，而是采取近似手段来得到算法的运行时间的数学模型。

### 近似

在建立算法运行时间的数据模型时，我们会多次用到近似的概念，舍弃掉不重要的因素，目的是建立简洁的模型。

#### 执行每条语句的耗时的近似
编程语言的每一条语句，会被编译器编译成机器码，然后执行。整个环节受到编译器、操作系统、CPU、内存、时钟、具体指令等影响，难以准确的量化。

因此，我们只考虑到编程语言层，认为所有基本操作（算数、比较、逻辑等）的执行时间都是相同的，这样我们就不需要考虑执行每条语句的耗时。

#### 多项式的近似
对于上述运行时间的数学表达式，当N较大时，不同子项的影响不同，我们只关心影响最大的项，使用**近似符号**：

$$\sim N^3/6$$

### 增长数量级
算法运行时间表达式中，不包含常数因子的部分，被称为`增长数量级`。我们需要熟悉常见的增长数量级（见书117页）。

## 内存消耗的数学模型
略，分析方法基本和分析运行时间相同。如果对于Java语言的内存消耗的**定量分析**感兴趣，可以读下本书的1.4.9部分。

## 输入对算法性能的影响
很多算法的性能会受到输入的性能影响，一般分别使用以下定语：

`最佳情况`

`最差情况`

`平均情况`

## ~表示和大O表示法
本书使用近似来表示省略低阶项的数据，数据可能是执行时间、内存消耗、比较次数等等，取决于上下文。

大O表达法是算法领域描述算法性能的一套“通用语言”，但是本书并没有采用。存在3个符号：

- $O(N^2)$，表示增长数量级的上界
- $Ω(N^2)$，表示增长数量级的下界
- $Θ(N^2)$，当且仅当增长数量级的上界和下界相同时，表示增长数量级

> 这三种符号都有准确的数学定义，见本书131页。
> 一般情况下，我们只关心增长数量级的上界，因此只使用 $O$ 表示，即使上界和下界相同时。

举一个例子：

在大小为N的未排序数字数组中找到数字0的索引。

本书会描述为：采用遍历算法，最佳情况下的运行时间为`1`，最坏情况下的运行时间为`~N`。

使用大O表示法会描述为：采用遍历算法最佳情况下的运行时间为 $O(1)$ ，最坏情况下的运行时间为 $O(N)$ ；或者遍历算法最佳情况下的**时间复杂度**为 $O(1)$，最坏情况下的时间复杂度为 $O(N)$。

>对应的，存在空间复杂度概念。
