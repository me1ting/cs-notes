# 问题描述

给出一个长度为N的文本和一个长度为M的模式字符串，如何在文本中找到与模式相同的子字符串。

# 暴力算法

```go
// 伪代码
text := "AABAABB"
pat := "AABB" //pattern

out: for i := 0;i<len(text);i++ {
    for j=0;j<len(pat)&&i+j<len(text);j++{
        if text[i+j] != pat[j]{
            continue out
        }
    }
    if j == len(pat){
        return j
    }
}
return false
```

暴力算法的价值在于：让我们理解算法可以优化的方向，暴力算法按照一位一位的从头开始匹配，过去的匹配经验被完全丢弃，如果能够利用经验，那么就能改进算法效率

# KMP算法

KMP是三位发明者名字的缩写。

基本思想：

![](assets/mspaint_bgyOAQ2Npq.png)

这个示例中我们可以重置为已匹配`text[3:4]`的状态。

![](assets/mspaint_7BFPfGnkEu.png)

这个示例我们可以重置为已匹配`text[3:6]`的状态。

## DFA表

可以使用一个`dfa[][]`（类型`int[rune][int]`），其中`int[c][j]`表示在当前匹配位置`j`上匹配了字符串`c`时，`j`的下一个值。

根据规则，`dfa[pat[j]][j] = j+1`，在位置`j`上匹配了part[j]上的字符，则下一个匹配位置为j+1。

比如，上面的第二个例子中`dfa['B'][5] = 3`。

使用dfa时的算法步骤：

```go
public int search(text, pat:string){
    N :=text.length()
    M := pat.length()

    for i, j:=0, 0;i<N && j < M;i++ {
        j = dfa[text[i]][j] // 注意这里的i, j与暴力算法中的i, j并不同
    }
    if j == M {// 匹配
        return i - M;
    }else{
        return -1;
    }
}
```

## 构建DFA

```java
dfa = new int[R][M];//dfa[c][j]的值为下一个j的位置
dfa[pat.charAt(0)][0] = 1;// dfa[c0][0]的值自然为1
for (int x = 0, j = 1; j < M; j++) {
    for (int c = 0; c < R; c++)
        dfa[c][j] = dfa[c][x]; // 复制匹配失败时，使用重启位置的值
    dfa[pat.charAt(j)][j] = j + 1; // dfa[cj][j]的值自然为j+1
    x = dfa[pat.charAt(j)][x]; // 更新重启位置
}
```

这是一段精巧设计的代码，即使有了以上注释，也很难理解。

这段代码需要的执行时间为`~MR`，需要的空间也为`~MR`，其中M为模式的长度，R为字符集的大小。

但是，我们可以发现，对于没有出现在模式中的字符，我们完全可以直接返回`0`，我们只需要计算出现在模式中的字符`c`的`dfa[c][j]`。

## 分析

KMP算法分为两个阶段（M为模式长度，N为字符串长度，R为字符集大小）：

- 构造DFA，需要时间和空间~MR
- 查询字符串，需要~N

其最大的优点在于：线性算法，实现了理论上的最下界；只需要对字符串进行一次扫描。

# BM算法

与KMP算法一样，BM也是算法发明者的名字缩写。

## 简化的BM算法

《算法4》一书介绍的由作者简化后的BM算法，对一些可以优化的细节进行了省略，使用未优化的版本。

BM算法是从末尾往前进行匹配，会存在3种情况：

- 字符S（text[i+j-1]）没有出现在模式中，跳过`text[:i+j-1]`的内容
- 字符S出现在模式中，从右向左的第一位置，在当前匹配位置的左边，那么可以将这两个位置对齐（调整i）
- 字符S出现在模式中，从右向左的第一位置，在当前匹配位置的右边，此时没有更多的信息，没法跳过一些元素，只能让i按最基本的方式行动：前进一步

情况2：

![情况1](assets/mspaint_fnCS6BIAiN.png)

情况3：

![](assets/mspaint_O7TmxGhcjn.png)

>看到情况3的示例，如果喜欢思考的人可能会想到：
>
>我们记录E从右往左的第二个位置，那么是不是就可以对齐到第二个E的位置呢？
>
>确实是可以，但第二个E可能在其它例子是不存在的，因为我们学习的是BM基础的部分，不做额外考虑。

# 情况2的优化

情况2中，我们从右往左匹配了部分内容，这部分的匹配结果能否利用起来优化算法的效率呢？

// TODO

# 基于指纹的RK算法

假设存在一个计算时间为常数的能够动态计算子字符串指纹的哈希算法，那么只需要一次遍历就能找到子字符串。

这个算法存在两个核心：

- 如果以常数的效率动态计算子字符串的hashcode
- hash匹配后如何校验子字符串匹配

## hashcode的计算
其实就是`除留余数法`和`Horner方法`，第一次匹配时需要完整的计算长度为M的子字符串的哈希函数，后续匹配时只需要减去开头丢弃的字符的量，再加上末尾新增的字符的量，就可以在常数时间内得出下一个匹配的子字符串的哈希值。

```
//txtHash是一个余数，+q是为了避免结果为负数
txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;
txtHash = (txtHash*R + txt.charAt(i)) % q;
```
>R为进制，$R^M$为M位置的权重，比如10进制，其第4位的权重为`10000`

# 总结

本文总结了经典的子字符串查找算法，但在实际应用中还需要参考一些实例，据说`BM`是常见软件（文本编辑器等）的子字符串查找基础，但未考证。

# Refs

《算法4》5.3 子字符串查找
