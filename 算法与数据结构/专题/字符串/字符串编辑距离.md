# 字符串编辑距离

Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离的算法是首先由俄国科学家 Levenshtein 提出的，故又叫 Levenshtein Distance 。

## 编辑距离不同于最长公共子序列

举例：

```
a = "a1b22c"
b = "3a44b5c"
```

两个字符串的最长公共子序列为3，如果接触过最长公共子序列的人会以为它们的编辑距离为`max(7,6)-4 = 3`。

但是，从a变化到b需要经历以下步骤：

```
a1b22c
3a1b22c//插入3
3a14b22c//插入4
3a44b22c//将1修改为4
3a44b2c//删除2
3a44b5c//将2修改为5
```

实际需要5个步骤。

## 计算编辑距离

使用动态规划可以计算编辑距离，对于字符串`a[0:i]`,`b[0:j]`（这里包括i,j），我们称状态`Equals(a[0:j],b[0:j])`为两个字符串已经相同了，使用`Distance(a[0:j],b[0:j])`记录达成该状态的编辑距离。

那么状态`Equals(a[0:i],b[0:j])`可以从3种状态演变：

- `Equals(a[0:i-1],b[0:j-1])`。当`a[i]==b[j]`时，此时`Distance(a[0:i],b[0:j])`等于`Distance(a[0:i-1],b[0:j-1])`。否则，需要将`a[i]`,`b[j]`修改为相同的距离，此时编辑距离+1
- `Equals(a[0:i-1],b[0:j])`，需要删除`a[i]`或者在`b[j]`插入`a[i]`，此时编辑距离+1
- `Equals(a[0:i],b[0:j-1])`，需要删除`b[j]`或者在`a[i]`插入`b[j]`，此时编辑距离+1

虽然状态`Equals(a[0:i-1],b[0:j])`和`Equals(a[0:i],b[0:j-1])`，可以由`Equals(a[0:i-1],b[0:j-1])`演变，但我们不能保证是`Equals(a[0:i-1],b[0:j-1])`的编辑距离决定了前两者的编辑距离，因此即使是`a[i]==b[j]`，我们任然要对这3种状态的推算得到的编辑距离取最小值，作为达成`Equals(a[0:i],b[0:j])`的编辑距离。