# 散列表

在计算机存储中，基于地址的直接访问是最快，比如数组。

`散列表`（也称作哈希表,hashmap,hashtable...）正是利用了数组来存储数据。使用一种方法，将`key`映射为索引从而实现直接访问，这种方法称为`散列函数`（也称作哈希函数）。

## 散列函数

散列函数应该利用数据的所有信息，典型如Java中的`Double`和`String`的`hashCode()`实现。

将序列映射到`hashcode`可以看作是计算一个多项式（称为Horner方法），使用一个小素数如31作为基数，Java中的String、List等采取了这种方式。

对于自定义类型，我们可以将类型的所有字段作为一个序列，然后采用Horner方法，计算hashcode：

![](_images/20200825173327077_29484.png)

![](_images/20200825173343622_13292.png)

最后得到的 hashcode 范围为 $-2^{31} \to 2^{31}-1$，还需要转换为数组的索引，这个转换取决于具体实现。

## 冲突解决

存在不同 key 但相同的 index 的情况，需要解决这种冲突，有两种解决办法。

### 拉链法

使用子容器来存储位于相同索引上的数据，教学时一般采用链表，实际应用中，比如Java的`HashMap`使用了红黑树。

### 探测法

`探测`：尝试使用数组的其它位置来存储冲突的元素。存在多种探测方法。

#### 线性探测法

插入时，尝试使用冲突位置的下一个位置来存储元素，如果还是冲突，则继续寻找下一个位置。

`键簇`：使用探测法时，数组中聚集的连续元素称为键簇。

有两种删除方法：

- 找到目标元素，并删除。同时将元素所在键簇的后续元素重新插入到散列表中。
- 使用标记删除，在 resize 时进行清理。

#### 其它探测法

//more

## 容量调整

当散列表的元素数量M越接近数组容量N时，对于`拉链法`，将出现更多的元素拥有相同的 hashcode 而聚集在子容器上；对于`探测法`，将出现更多的更大的键簇。这将导致散列表的性能下降。

另一方面，当数量M远小于N时，会造成内存空间的浪费。

总之，需要根据 $M/N$ 动态的调整 $N$ 的大小，一般将 $M/N$称为哈希表的`装填因子`。

拉链法的装填因子推荐在 $0.5 \to 1$之间，一般采用 0.75（《数据结构与算法分析2》，Java）。线性探测的装填因子应当小于 0.5（《算法4》p304）。

调整容量时，我们创建一个新的底层数组，并将旧数组的元素插入到新数组中，对于使用标记删除的探测法哈希表，需要跳过被删除的元素。

## 性能

散列表的性能分析使用了`摊还分析`，平均情况下，查找、插入、删除、容量调整的时间复杂度为 $O(1)$。

### 一些可能导致散列表出现性能问题的原因

计算hash的消耗，可能导致哈希表的性能比查找树差，比如在Java早期版本中`String`的hash值没有进行缓存，使用String做为键会导致性能问题。

由于hash函数的存在，哈希表的性能类似依赖于某种随机性，存在最差情况的可能，在一些对性能要求保证的场合，使用查找树是一个更好的选择。Java8使用红黑树取代链表，保证了最差情况下的性能为 $O(logN)$。

通过构造特定的键，可能导致性能问题，从而对服务器进行拒绝服务攻击。如使用拉链法，导致大部分键都位于链表之上。Java8使用红黑树来取代链表，避免了这个问题。

# 参考资料

《算法4》3.4 散列表 p293

《数据结构与算法分析2》chapter5 散列
