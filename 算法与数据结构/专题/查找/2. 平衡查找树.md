# 平衡查找树

`平衡`：使得树的节点尽可能均匀的分布，从而使得树的高度尽可能小。严格的定义可以通过限定**任一节点子树高度差**来实现。

查找树的性能受到树的深度影响，通过对查找树进行平衡，可以获得较好的、稳定的性能。

已经有多种查找树的平衡策略被发明，其中最经典的是红黑树。

# 红黑树

在论文《A Dichromatic Framework for Balanced Trees》（《算法4》的作者是论文作者之一）中，一种定义二叉平衡树的方法被提出，通过**着色为红黑**来表示节点的平衡信息。

如下定义了红黑树：

- 每个节点要么为红色，要么为黑色，空节点视作黑色
- 根是黑色
- 如果一个节点是红色，那么它的子节点必须是黑色
- 从一个节点到达null引用的每一条路径上，黑色节点的数目必须相同

以上规则使得：从根到最远叶子的路径不超过从根到最近叶子的路径的两倍，这就是**红黑树的平衡性**。

## 红黑树的实现

有了`着色性质`，红黑树的实现无非是罗列并处理各种可能的情况，更多是体力劳动而非智力游戏。

### 插入

二叉查找树的插入是以`叶节点`的方式进行，如果涂成黑色，会违背性质4，那么**只能以红色节点插入**。

而以红色节点插入可能会违背性质3，此时需要进一步处理，其中的基本操作是`旋转`和`换色`。

细节见《数据结构与算法分析2》12.2.1 自底向上的插入，12.2.2 自顶向下的插入。

### 删除

元素如果位于树叶上，如果是红色，直接删除即可；但如果是黑色，很麻烦。解决思路是，在从上到下查找元素所在节点的过程中，不断的进行变化，使得最终保证树叶是红色的。

细节见《数据结构与算法分析2》12.2.3 自顶向下的删除。

元素所在节点如果有子树，使用左子树的最大值或者右子树的最小值替代元素，然后递归删除用于替代的元素所在节点。此时，替代元素所在节点必然最多只有一个子节点，且为红色。如果替代元素存在子节点，那么用子节点替代替代元素所在节点。如果不存在子节点，那么就是上述所说的：删除叶节点。

## 性能

由于红黑树的平衡性，红黑树的最大高度不超过 $2logN$，因此查找、插入、删除的时间复杂度为 $O(logN)$。

## 左倾红黑树

在《算法4》中，作者讲解的是`左倾红黑树`，红黑树的一种简化版本，从而方便教学。

但是书中使用2-3查找树来讲解左倾红黑树，个人不太喜欢这种方式，因此并没有深入了解。

## 现实中的红黑树

红黑树从发明到现今，并没有太多理论上的突破，目前编程界使用的依然是经典版本的红黑树，其代码已经经过高度优化、固化，没有给使用者留下多少调整空间。

Java的HashMap中的[红黑树代码](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java)（2168行）就是从微软的CLR复制而来的，而非自己实现。

# 参考资料

《算法4》3.3 平衡查找树

《数据结构与算法分析2》12.2 红黑树

[RedBlackTree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)wiki