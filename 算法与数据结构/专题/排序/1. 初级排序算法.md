# 初级排序算法

习惯上将`选择排序`,`插入排序`,`冒泡排序`算法称为初级排序算法。这些排序算法是最简单的排序算法，是构建排序算法知识的基础，同时在工程领域依然被使用。

# 选择排序

选择排序的描述见书（算法4 p155 2.1.2），简单来说，就是 选择-交换 的不断重复。

## 选择排序的性质

**运行时间和输入无关** 

选择排序的运行是固定的，无关输入数据。进行了N-1次选择，每次选择分别比较了N-1,N-1...1次，每次选择分别进行了1次交换。

选择排序的时间复杂度为 $Θ(N^2)$。

**数据移动最少**

选择排序在所有排序算法中，对数据的移动操作是最少的。

# 插入排序

插入排序的描述见书（算法4 p157 2.1.3），简单来说，就是不断保证局部有序性，直到整体有序性。

```go
func Sort(nums []int) []int {
	n := len(nums)
	for i := 1; i < n; i++ {
		a := nums[i]
		j := i
		//从后向前查找交换
		for ; j > 0; j-- {
			b := nums[j-1]
			if a < b {
				nums[j] = b
			} else {
				break
			}
		}
		nums[j] = a
	}

	return nums
}
```

一个值得注意，但很可能习惯性忽略的细节是，在查找元素的插入位置时，是从后向前，边查找边交换。

## 插入排序的性质

插入排序进行了N-1轮，每轮比较 1 - M 次（M为1,2,3,4...N-1），每轮交换 1 - M 次。

插入排序的运行时间为 $~N - ~N^2$。数据是否存在局部有序性极大影响了插入排序的效率。

**对于部分有序的数据来说，插入排序的效率较高。**

# 冒泡排序

冒泡排序是一个有[争议](https://en.wikipedia.org/wiki/Bubble_sort#Use)的排序算法，因为它在工程领域用不到，仅有着一点教学意义，因此某些书（如《算法4》）并没有介绍该算法。

其基本思想是将相邻数据进行比较，如果逆序则进行交换，这样最末尾的数据就是最大值。重复N-1次，得到排序后的数组。

```go
func Sort(nums []int) []int {
	n := len(nums)
	for i := n-1; i > 0; i-- {
        swapped := false
		for j = 0; j < i; j++ {
            a := nums[j]
            b := nums[j+1]
			if a > b {
				nums[j] = b
                nums[j+1] = a
                swapped = true
			}
		}
		if !swapped {
            break
        }
	}

	return nums
}
```

冒泡排序一个实现细节是：使用一个变量记录是否发生交换，如果某轮“冒泡”过程中未发生交换，则说明数据是有序的。

## 冒泡排序的性质

当数据是有序时，由于`swapped`变量的存在，只需要一轮“冒泡”，冒泡排序在最佳情况下的时间复杂度为 $O(N)$ 。

当数据是逆序时，冒泡排序需要N-1轮，每轮需要N-1,N-2...1次交换，冒泡排序在最差情况下的时间复杂度为 $O(N^2)$ 。

虽然与插入排序具有相同的时间复杂度，但由于交换的次数较多，冒泡排序的实际性能不如插入排序和选择排序。

