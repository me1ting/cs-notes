# 事务

`事务`是访问并可能更新数据的一个基本单元。

	对于数据库用户来说，`事务`是通过SQL语句或者客户端API来获取的。

## ACID性质

事务存在以下性质：

- 原子性(atomicity)，事务作为一个整体，要么执行成功，要么执行失败
- 一致性(consistency)，事务执行应当能保证数据的一致性
- 隔离性(isolation)，并发执行的事务互不影响
- 持久性(durability)，成功执行的事务对数据库的修改必须是永久的

这些性质通常被称呼为`ACID`性质，其中`隔离性`对于数据库性能存在巨大影响，因此针对该性质存在妥协的解决方案。

## 事务的状态

事务有以下状态：

- 活动的，初始化后的事务
- 部分提交，执行完成所有语句但操作没有被持久化
- 已提交，执行成功的事务
- 已失败，执行失败的事务
- 已中止，执行失败并回滚的事务

## 事务的隔离级别

强`隔离性`要求并行执行的事务完全互不影响，这意味着大多数情况下，事务只能`串行执行`。

权衡性能，现实情况下允许弱隔离性，术语`隔离级别`用于定义不同强度的隔离性。

SQL标准规定了以下隔离性级别：

- `未提交读`(`read uncommitted`)，读取结果包括未提交数据
- `已提交读`(`read committed`)，读取结果只包括已提交数据
- `可重复读`(`repeatable read`)，读取结果只包括事务中第一次读时的已提交数据
- `可串行化`(`serializable`)，事务完全互不影响

*我们按照隔离性强度从大到小进行排序：可串行化、可重复读、已提交读、未提交读*

不同的隔离级会出现一些违背一致性的读取结果，使用以下术语描述：

- `脏读`，当事务隔离级别为`未提交读`时，事务会读取到未提交的数据，这些数据可能会被另一个事务修改，甚至回滚
- `不可重复读`，当事务隔离级别为`已提交读`时，一个事务前后两次读取会返回不同的数据，包括这两次读取之间由其它事务并行修改、删除的数据
- `幻读`，当事务隔离级别为`可重复读`及其以下时，事务中前后两次相同读取，后一次读取会读取到其它事务提交的插入的新数据

### 隔离级别的作用域

数据库系统存在`全局隔离性级别`，事务本身也可以设置其隔离性级别。

### 事务,隔离级别与正确性

除了`可串行化`级别，事务的隔离级别仅对`事务中的读操作`进行了约束，而这并不能保证正确性。

举例来说，当隔离级别为`可重复读`时：

| 顺序/事务 | 事务A   | 事务B |
| ----- | --------- | ----------- |
| 1 | 读取balance | |
| 2  | | 更新balance |
| 4 | | 提交 |
| 4 | 使用读取的balance更新balance | |
| 5  | 提交 | |

事务A利用读取的balance来更新balance，但在这期间事务B已经更新了balance，违背了正确性。

**因此，只使用事务来包裹SQL语句，只设置事务隔离级别（除了可串行化级别），并不能保证应用/数据的正确性。**

那如何才能保证数据的正确性呢？我们就将在下一章了解。

## 参考资料

《数据库系统概念》v6 14. 事务