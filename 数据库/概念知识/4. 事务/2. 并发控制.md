# 并发控制

我们将在这里介绍DBMS用于控制并发访问的基本机制，这些机制是DBMS用于支持事务以及其隔离级别的底层方法，部分通过API（如SQL）暴露给了上层使用。

## 锁

### 共享锁和排他锁

定义：

- 共享锁(S)：获取共享锁的事务具有能读不能写
- 排他锁(x)：获取排他锁的事务能读能写

### 锁的相容性

DBMS中的锁，存在`相容性`，指当一个事务拥有某类锁时，其它事务能否获取特定锁。

| | S | X |
| --| -- | -- |
| S | true | false |
| X | false | false |

如果事务申请特定锁时，已存在与之不相容的锁被其它事务持有，那么该事务就会进入等待，直到不相容的锁被释放。

### 两阶段锁

`两阶段锁`指事务的整个过程包括：

- 增长阶段，事务可以获取锁，但不能释放锁。其中执行SQL，事务提交都属于该阶段。
- 缩减阶段，事务可以释放锁，但不能获取锁。

### 多粒度和意向锁

数据库是多层次节点组成的树：库、表、记录。每个节点能加锁，`多粒度`表达的就是这个意思。当给节点加锁时，会隐式的给节点的所有子节点加相同的锁。

假设事务a给行进行了加锁，而另一个事务b想给表加锁，需要搜索整个树才能判断是否能加锁，而这是不够高效的。

`意向锁`就是用来解决上述问题：

在节点A上（如表）使用意向锁，表示将在节点A的子节点进行加锁操作，这会导致A的所有祖先节点隐式的加上了意向锁。其它线程就能快速判断能否在某个节点加锁。

这是添加意向锁后的`锁的相容性矩阵`。

| |`X`|`IX`|`S`|`IS`|
|---|---|---|---|---|
|`X`|Conflict|Conflict|Conflict|Conflict|
|`IX`|Conflict|Compatible|Conflict|Compatible|
|`S`|Conflict|Conflict|Compatible|Compatible|
|`IS`|Conflict|Compatible|Compatible|Compatible|

## 时间戳

//more

## 有效性检查

当数据库主要是读而写很少时，或者并发量较小时，可以使用一种轻量的并发控制机制，避免使用锁、时间戳等同步机制。

一个典型的使用有效性检查的过程包括：

- 读取阶段
- 有效性检查阶段
- 写阶段

用SQL示例来解释有效性检查：

```SQL
SLECT amount FROM WHERE id = 1
UPDATE account SET amount = 0 WHERE id = 1 and amount == 100
```

假设我们向id为1的账户扣100块钱，我们首先读取账户的余额为100块，扣完100块后余额为应为0。

在有效性检查阶段，我们检查数据库中的余额是否为100。如果数据库余额为0，更新用户的余额。

有效性检查认为执行会成功，是一种乐观的态度，因此使用有效性检查被称为`乐观锁`，与之相对的，相对的，前面介绍的锁被称为`悲观锁`。

有效性检查仅适合冲突较少时的场景，一些场景下需要重试少量次数。

## 参考资料

《数据库系统概念》v6 15. 并发控制